---
layout: post    
title: 数据结构与算法学习心得    
date: 2019-01-24    
tags: 数据结构与算法          
---

<br>
### 前言    
本文档主要是针对在学习和工作中对于数据结构与算法的感悟，主要包括以下内容常用的基础的数据结构与算法。其涉及到以下数据结构：数组、链、栈、队列、散列表、二叉树、堆、跳表、图、树等。涉及到的算法主要包括递归、排序、二分查找、搜索、哈希算法、分治算法、回溯算法、对台规划、字符串匹配算法等。     
对于此部分的学习不要死记硬背，要掌握分析的能力，抓住算法的特定，应用场景。用到的时候，能够想到即可，再花些时间弄懂即可。知识需要沉淀，不要想试图一下子掌握所有，学习知识的过程是反复迭代、不断沉淀的过程。



<br>
### 基础知识    
数据结构，就是一组数据的存储结构。算法，就是操作数据的一组方法。数据结构视为算法服务的，算法要作用于特定的数据结构。            
#### 复杂度分析      
数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标，其中主要使用的是时间和空间复杂度分析。    
##### 大O复杂度      
代码的执行时间T(n)与每行代码的执行次数n成正比，其表达式如下所示：    
```
T(n)=O(f(n))
```         
注释：   
* `T(n)`：表示代码的执行时间。    
* `n`：表示数据规模的大小。          
* `f(n)`：表示每行代码执行次数的总和。    
* `O`：表示代码的执行时间T(n)与f(n)成正比。    

大O时间复杂度，并非代码执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作**渐进时间复杂度**，简称**时间复杂度**。其表示法，指出了最糟糕情况下的运行时间。    

##### 时间复杂度分析    
1. 只关注循环次数最多的一段代码。由于大O表示法只是表示一种变化趋势，因此会忽略掉公式中的常量、低级、系数。  
2. 将所有复杂度相加，总复杂度等于量级最大的那段代码复杂度。    
3. 对于嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。    
4. 对于多规模要求多个规模复杂度之和。    

##### 常见时间复杂度分析     
###### 以下将列举几种常见时间复杂度量级，按数量级递增     
* 常量阶：O(1)    
* 对数阶：O(logn)    
* 线性阶：O(n)    
* 线性对数阶：O(nlongn)    
* 平方阶：O(n^2)、立方阶阶O(n^3)...K次方阶O(n^k)    
* 指数阶：O(2^n)    
* 阶乘阶：O(n!)    

###### 常见的复杂度级别     
**多项式阶**：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。其中常见的如下所示
> 1. O(1)：只要代码的时间复杂度不随n的增长而增长，这样代码的时间复杂度表示常量级。        
> 2. O(log n)、O(n*log n)：不管以2为底、以3为底、还是以10为底，都把所有对数阶的时间复杂度记为O(log n)，因为对数之间可以相互转化，`log3^n =log3^2 * log2^n`，所以O(log3^n)=O(C*logn)，其中C=log3^2是一个常量，忽略此系数。    
> 3. O(m+n)：对于无法评估的m和n两个数据规模，要用此方法表示。  

##### 空间复杂度分析    
空间复杂度全称为渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。    
        

<br>
### 常见数据结构    
#### 数组    
数组（Array）是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。    
数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。    
##### 改善数组低效的“插入”和“删除”    
* 当数组中存储的数据没有任何规律，数组只是当做一个存储数据的集合，侧可以直接将数组插入第K个位置，为了避免大规模数据搬移，可以将原来k位置的数据摆一道数组元素的最后。    
* 在默写场景下，并非要数组中数据连续性，这是可以考虑将多次删除操作集中在一起执行，从而每次删除操作并不是真正的搬移数据，而是记录数据已经被删除，当数组没有更大空间存储数据时，才触发一次真正的删除操作，这样可以大大减少删除操作导致的数据搬移。    
* 总结，不要去死记硬背某个数据结构或者算法，要学习它背后的思想和处理技巧，这些东西才是最有价值的。    

##### 用数组比高级数组更合适场景    
1. Java ArrayList无法存储基本类型，例如int、long，需要封装为Integer、Long类型，而Autoboxing、Unboxing则有一定的性能消耗，若是特别关注性能，或是希望使用基本类型，就可以选用数组。    
2. 数组大小事先已知，并且对数组的操作非常简单，用不到ArrayList提供的大部分用法，也可以直接使用数组。    
3. 多维数组用数组更加直观。    

##### 数组寻址公式    
* 一维数组寻址公式：    
> a[k]_address = base_address + k * type_size    


* 二位数组寻址公式m*n数组：    
> a[i][j]_address = base_address +(i * n + j) * type_size    

#### 链表    
链表不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。    
常见的链表结构为：单链表、双向链表、循环链表。    
##### 链表实际用法    
在实际软件开发中，从链表中删除一个数据基本有两种情况：    
* 删除节点中“只等于某个定值”的节点。    
> 单纯的删除操作时间复杂度为O(1)，但是遍历查找的时间为主要的耗时点，对应的时间复杂度为O(n)，根据时间复杂度分析中加法法则，删除等于给定值节点对应的链表操作的总时间复杂度为O(n)。    


* 删除给定指针的节点。    
> 已知要删除的节点，需找到此节点的前驱节点，单向链表需要从链表头开始找，此时时间复杂度为O(n)，对于双向链表直接可以取得，此时时间复杂度为O(1)。     

##### 链表代码书写常用技巧        
优雅的写出链表代码5大技巧：    

###### 理解指针或引用的含义    
将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。    

###### 警惕指针丢失和内存泄漏（单链表）    
关键为将拆分的数据，挂载到已知变量。    

###### 利用“哨兵”简化实现难度    
链表中的“哨兵”节点是解决边界问题，不参与业务逻辑。    

###### 重点留意边界条件处理    
对于边界处理方面，需要常问下面4个问题：    
1. 如果链表为空时，代码是否能正常工作？    
2. 如果链表只包含一个节点时，代码是否能正常工作？    
3. 如果链表只包含两个节点时，代码是否能正常工作？    
4. 代码逻辑在处理头尾节点时是否能正常工作？    

###### 举例画图，辅助思考    
核心思想：释放脑容量，留更多的给逻辑思考，产生一个清晰思路。    



   

<br>
参考链接：    

<br> 
转载请注明：[HunterYuan的博客](https://clodfisher.github.io/) » [数据结构与算法学习心得](https://clodfisher.github.io/2019/01/StructuresAndAlgorithms/)            