---
layout: post    
title: Go常见知识点汇总    
date: 2019-02-26    
tags: Go          
---

<br>
### 前言    
对于工作和学习中遇到，容易忘记的知识点进行汇总，方面以后使用的时候，能够及时查到相关点，节约重新学习和搜索的时间。    

<br>
### GO工程布局        
此部分主要总结关于Go语言开发过程中，实现工程化方面知识点。      

**同一个目录下怎样声明源码包**    
> 在同一个目录下的源码文件都需要被声明为属于同一个代码包，这有这有才能通过编译。    

**源码文件代码包声明的基本规则**    
> 第一条：同目录下的源码文件的代码包声明语句要一致。也就是说，他们要同属于一个代码包。这对于所有源码文件都是适用的。    
> 第二条：源码文件声明的代码包的名词可以与其所在的目录的名称不同。在针对代码包进行构建时，生成的结果文件的主名称与其父目录的名称一致。    

**源文件声明代码包与目录名不同如何使用**    
> 源文件所在的目录相对于src目录的相对路径就是他的代码包导入路径，而是将使用其程序实体是给定的限定符（lib.Func，其中lib是限定符，Func是实体）要与它声明所属的代码包名称对应。    

**实体的首字母大小写有何区别**     
> 名称的首字母为大写的程序实体才可以被当前包外的代码引用，否则它就只能被当前包内的其他代码引用。    

<br>
### GO实体    

**什么是程序实体**    
> 在go语言中，程序实体是变量、常量、函数、结构体和接口的统称。使用之前必须先定义程序实体，让后再去使用。程序实体的名字呗统称为标识符，使用来被程序标识和使用的。    

**类型推断的好处**    
> Go语言的类型推断可以明显提升程序的灵活性，使得代码重构变得更加容易，同时又不会给代码的维护带来额外负担（实际上，它恰恰可以避免散弹式的代码修改），更不会损失程序运行效率。    

**变量重声明前提条件**    
> 1. 由于变量的类型在初始化时就已经确定了，所以对它再次声明对赋予的类型必须与其原本的类型相同，否则会产生编译错误。    
> 2. 变量的重声明只可能发生在一个代码块中。如果与当前的变量重名的是外层代码块中的变量，那么久是另外一种含义了，覆盖。
> 3. 变量的重声明只有在使用短变量声明时才会发生，否则无法通过编译。如果要在此处声明全新的变量，那么就应该使用包含关键字var的声明语句，但是这时就不能与同一代码快中的任何变量由重名。    
> 4. 被"声明并赋值"的变量必须是多个，并且其中至少有一个是新的变量。这时我们才可以说对其中的旧变量进行了重声明。    
> 5. 样例`var err error;n,err := Func()`。     

**引用程序实体时，查找过程**    
> * 首先，代码引用变量的时候总会最优先查找当前代码块中的那个变量。不包含任何子代码块。    
> * 其次，如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，从直接包含当前代码块的那个代码开始，一层层向上查找。    
> * 一般情况下，程序会一直查到当前代码包代表的代码块。如果仍然找不到，那么Go语言的编译器就会报错，由于限定符的原因。    
> * 特殊情况，如果我们把代码包导入语句写成import . XXX形式，就会让这个“XXX”包中公开的程序实体，被当前源码代码中的代码，视为当前代码包中的程序实体。      


**类型断言表达式**    
> * 类型断言表达式的语法形式为x.(T)，其中的x代表要被判定类型的值，这个值必须为接口类型，不过具体哪个接口类型其实无所谓，T为类型自变量。    
> * 常用断言表达式为：`value, ok := interface{}(countainer).([]string)`或`value := interface{}(countainer).([]string)`其中前者表示将结果赋值给两个变量，`value`和`ok`，ok为布尔值，`true`时，类型判定正确，被判定的值江北自动转换为`[]string`类型值赋予`value`，否`ok`为`false`，`value`为`nil`;后者当判定为否时将会引起`panic`异常。    
> * 核心图片： ![](/images/posts/2019-2-29-GoKnowlePoint/GoKnowlePoint0.jpg)         

**{}含义**   
> * 一对不包裹任何东西的花括号，除了可以代表空的代码块之外，还可以用于表示不包含任何内容的数据结构（或者说数据类型）。    
> * 举例：`struct{}`，代表不包含任何字段和方法的，空的数据体类型；`interface{}`，代表不包含任何方法定义的，空的接口类型；对于一些集合类的数据类型来说，{}还可以用来表示其值不包含任何元素，比如空的切片值`[]string{}`，以及空的字典值`map[int]string{}`。     

**类型转换规则**     
> * 类型转换表达式的基本写法为T(x)，其中的T为类型，x可以是一个变量，也可以是一个代表值得字面量（比如1.23和struct{}），还可以是一个表达式。x称为源值，类型是源类型，而T代表的类型就是目标类型。   
> * 类型转换常见坑：    
> 1. 首先，对于整数类型值，整数常量之间的类型转换，原则上只要源值在目标类型的可表示范围内就是合法的。    
> 2. 把一个 整数值转换为一个string类型的值是可行的，但值得关注的是，被转换的整数值应该可以代表一个有效的Unicode代码点，否则转换结果将会是“�”（仅由高亮的问好组成的字符串值）。    
> 3. string类型与各切片类型之间的互换，常见切片为`[]byte`和`[]rune`。    

**别名类型和潜在类型**    
> * 核心图片： ![](/images/posts/2019-2-29-GoKnowlePoint/GoKnowlePoint1.jpg)         
> * 别名类型与源类型的区别只在名字上，它们完全是相同的。别名类型主要是为了代码重构而存在的。        
> * 类型再定义，完全定义了一个不同的类型，被重定义类型为潜在类型，其含义是某个类型在本质上市那个类型，或者是那个类型的集合。如何两个潜在类型相同，却属于不同类型，他们之间是可以进行类型转换的，但是不能进行判等或比较，它们的变量之间也不能赋值。再定义类型与潜在类型的值，也可以使用类型转换表达式进行转换。            
     
<br>
### 数组与切片    

**表示方式不同之处**     
> * 切片可以看做是对数组的一层简单的封装，因为在每个切片的底层数据结构中，一定会包含一个数组。数组可以被叫做切片的底层数组，而切片也可以被看做是对数组某个连续片段的引用。    
> * Go语言的切片类型属于引用类型，同属于引用类型的还有字典类型、通道类型、函数类型；而Go语言的数组类型则属于值类型，同属于值类型的有基础数据类型以及结构体类型。    
> * 数组和切片之上都可以应用索引表达式，得到的都会是某个元素。在它们之上也都可以应用切片表达式，也都会得到一个新的切片。     
> * 核心图片： ![](/images/posts/2019-2-29-GoKnowlePoint/GoKnowlePoint2.jpg)         

**切片与数组之间的关系**    
> * 有一窗口，可以通过这个窗口看到一个数组，但是不一定能看到该数组中的所有元素，有时候只能看到连续的一部分数据。其窗口就是切片是对数组的封装，窗口的长度，就是切片本身的长度。    
> * 核心图： ![](/images/posts/2019-2-29-GoKnowlePoint/GoKnowlePoint3.jpg)         
    
**切片的底层数组什么时候被替换**    
> * 确切地说，一个切片的底层数组永远不会被替换，因为只要有切片的创建和数据的追加都是产生一个新的切片类型，来执行新的底层数组或旧的底层数组。每次的操作都是把新的切片作为底层数组的窗口，而没有对原切片进行任何改动。    
> * 举例：在无需扩容时，append函数返回的是指向源底层数组的新切片，而在需要扩容时，append函数返回的是指向新底层数组的新切片。只要长度不会超过切片的原容量，那么使用append函数对其追加元素的时候就不会引起扩容，这只会使紧邻切片窗口右边的（底层数组中的）元素被新的元素替换掉。        
    
<br>
### 字典类型       

**字典的键类型不能使那些类型**    
> * Go语言规范规定，在键类型的值之间必须可以施加操作符`==`和`！=`（处理哈希碰撞）。换句话说，键类型的值必须要支持判等操作。由于函数类型、字典类型和切片类型的值并不支持判等操作，所以字典的键类型不能是这些类型。 另外，如果键的类型是接口类型，那么键值的实际类型也不能是上述三种类型，否则在程序运行过程中会引发`panic`（即运行时恐慌）。    
> * 如果键的类型是数组类型，那么还要确保该类型的元素类型不是函数类型、字典类型或切片类型。     
> * 如果键值类型是结构体类型，那么还要保证其中字段的类型的合法性。    
       
**优先考虑哪些类型作为字典的键类型**        
> * 从性能的角度来看，在整个映射过程中，“把键值转换为哈希值”以及“把查找到的哈希值与哈希桶中的键值做对比”，是两个重要耗时操作，因此可知，求哈希和判等操作的速度越快，对应的类型就越合适作为键类型。    
> * 对于所有的基本类型、指针类型、以及数组类型、结构体类型和接口类型，Go语言都有一套算法。这套算法就包含哈希和判等，以求哈希的操作为例，宽度（单个值需要占用的字节数）越小的类型速度通常越快。  
> * 对于数组类型的值求哈希实际上是依次求得它的每个元素的哈希值并进行合并，所以速度就取决于它的元素类型以及它的长度。    
> * 对于结构体类型的值求哈希实际上就是对它的所有字段值求哈希并进行合并，所以在于它的各个字段的类型以及字段的数量。    
> * 对于接口类型，具体的哈希算法，则有值得实际类型决定。    

**在值为nil的字典上执行那些操作成功与失败**        
> * 对于仅声明而不初始化的字典，它的值是nil，因此叫做nil字典。除了添加键-元素对，在一个键值为nil的字典上做任何操作都不会引起错误。若试图添加键-元素对，运行时系统就会抛出一个`panic`。    
> * 对于空map类型可以进行添加，而对于切片类型的nil和空都可以用append进行添加。          

<br>
### 通道类型       
不要通过共享内存来通信，而应该通过通信来共享内存。        

**通道基础知识**        
> * 在声明并初始化一个通道的时候，需要用到Go语言内建函数make，其要传入的参数必须含有通道类型的元素类型字面量（chan int）。在其后还可以接受一个int类型的参数（不能小于0），用来缓存通道（大于0）和非缓存通道。    
> * 一个通道相当于一个先进先出（FIFO）的队列。元素发送和接受都需要用到操作符`<-`，可叫做接送操作符，一个左尖括号紧接着一个减号形象地代表了元素值得传输方向。      

**通道的发送和接受存在哪些基本操作**          
> 1. 对于同一个通道，发送操作之间是互斥的，接受操作之间也是互斥的。    
> 在同一时刻，即使在并发情况下，运行时系统只会执行，对同一个痛的的任意个接收（发送）操作中的某一个，直到这个元素值被完全复制（副本）进（出）该通道之后，其它针对该通道的接收（发送）操作才可能被执行。        
> 2. 发送操作和接受操作中对元素值的处理都是不可分割的。    
对于通道中的同一个元素值来说，发送操作和接收操作之间也是互斥的，某一个处理元素都是一气呵成，绝对不会被打断。例如发送操作要么还没有复制元素值，要么已经复制完毕，绝不会出现只复制 了一部分的情况，接收操作在准备好元素的副本之后，一定会删除掉通道中的原值，决不会出现通道中仍有残留的情况。这即使为了保证通道中元素值的完整性，也是为了保证通道操作的唯一性。对于通道中的同一个元素值来说，它只可能是某一个发送操作放入的，同时也只可能被某一个接受操作取出。            
> 3. 发送操作在完全完成之前会被阻塞，接受操作也是如此。     
一般情况下，发送操作包括了“复制元素值”和“放置副本到通道内部”，而接受操作通常包含了“复制通道内的元素值”、“放置副本到接收方”、“删掉原值”，在所有这些步骤完成之前，发起该操作的代码会一直阻塞，直到所有步骤完成后，运行时系统会通知这句代码所在的goroutine,以使它争取据需运行代码的机会。    
阻塞代码其实是为了实现操作的互斥和元素值的完整。         

**通道不一定会作为数据传输的中转通道**          
> * 对于非缓冲通道，无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递，数据直接从发送方赋值到接受方，中间并不会用非缓冲通道做中转，其中方式为同步传递数据。也就是说只要双方对接上，数据才会传递。    
> * 对于缓冲通道，大多数情况下作为双方的中间件，元素值会先从发送方复制到缓冲通道，之后再由缓冲通道复制给接收方。但是，当发送操作在执行的时候发现空的通道中，正好有等待的接受操作，那么它会直接把元素值复制给接收方。    

**缓冲通道满时如何处理**     
>  通道已满，那么对他的所有发送操作都会被阻塞，它所有的goroutine会顺序第进入通道内部的发送队列，当通道中有元素值被接受走，这时，通道会有限通知最早因此而等待的，那个发送操作所在的goroutine，使其进行发送操作，所有的通知顺序总是公平的。    

**操作nil通道现象**    
> 对于值为nil的通道，不论它的具体类型是什么，对它的发送操作和接受操作都会永远地处于阻塞状态。他们所属的goroutine中的任何代码，都不再被执行。由于通道类型是引用类型，当我们只声明该类型的变量没有用make函数对其进行初始化时，该变量的值会是nil，因此一定不要忘记初始化通道。    

**发送和接收操作在什么时候会引发panic**     
> * 对于一个寂静初始化，但并未关闭的通道来说，收发操作一定不会引起`panic`，但是通道一旦关闭，再对它进行发送操作，就会引起`panic`。    
> * 如果试图关闭一个已经关闭了的通道，也会引发`panic`。注意，接收操作可以感知到通道的关闭，并且安全退出。    
> * 当把接收表达式的结果同时赋值给两个变量时，第二个变量的类型是bool类型，它的值如果是false就说明通道已经关闭，并且再没有元素可取。    
> * 如果通道关闭时，里面还有元素值未被取出，那么接收表达式的第一个结果，仍会是通道中的某一个元素值，而第二个结果值一定会是true，因此，通过接收表达式的第二个结果值，来判断通道是否关闭时可能有延时的。    
> * 有上述通道收发操作的特性，所以除非有特殊的保障措施，我们千万不要让接收方关闭通道，而应该让发送方做这件事。                                   

**单向通道的应用价值**       
> * 单向通道最主要的用途就是约束其它代码的行为。例如：接口类型声明一个方法，其只会接收一个发送通道作为参数，所以，在该接口的所有实现类型中的此方法都会受到限制。对于编写模块代码或者可扩展的程序库的时候很有用。对于调用只接受发送的函数，只需要把一个元素类型匹配的双向通道传给它就行，没有必要用发送通道，因为Go语言在这种情况下会自动地把双向通道转换为函数所需的单向通道。        


<br>
持续更新......

<br> 
转载请注明：[HunterYuan的博客](https://clodfisher.github.io/) » [Go常见知识点汇总](https://clodfisher.github.io/2019/02/GoKnowlePoint/)      