---
layout: post    
title: Go常见知识点汇总    
date: 2019-02-26    
tags: Go          
---

<br>
### 前言    
对于工作和学习中遇到，容易忘记的知识点进行汇总，方面以后使用的时候，能够及时查到相关点，节约重新学习和搜索的时间。    

<br>
### GO工程布局        
此部分主要总结关于Go语言开发过程中，实现工程化方面知识点。      

**同一个目录下怎样声明源码包**    
> 在同一个目录下的源码文件都需要被声明为属于同一个代码包，这有这有才能通过编译。    

**源码文件代码包声明的基本规则**    
> 第一条：同目录下的源码文件的代码包声明语句要一致。也就是说，他们要同属于一个代码包。这对于所有源码文件都是适用的。    
> 第二条：源码文件声明的代码包的名词可以与其所在的目录的名称不同。在针对代码包进行构建时，生成的结果文件的主名称与其父目录的名称一致。    

**源文件声明代码包与目录名不同如何使用**    
> 源文件所在的目录相对于src目录的相对路径就是他的代码包导入路径，而是将使用其程序实体是给定的限定符（lib.Func，其中lib是限定符，Func是实体）要与它声明所属的代码包名称对应。    

**实体的首字母大小写有何区别**     
> 名称的首字母为大写的程序实体才可以被当前包外的代码引用，否则它就只能被当前包内的其他代码引用。    

<br>
### GO实体    

**什么是程序实体**    
> 在go语言中，程序实体是变量、常量、函数、结构体和接口的统称。使用之前必须先定义程序实体，让后再去使用。程序实体的名字呗统称为标识符，使用来被程序标识和使用的。    

**类型推断的好处**    
> Go语言的类型推断可以明显提升程序的灵活性，使得代码重构变得更加容易，同时又不会给代码的维护带来额外负担（实际上，它恰恰可以避免散弹式的代码修改），更不会损失程序运行效率。    

**变量重声明前提条件**    
> 1. 由于变量的类型在初始化时就已经确定了，所以对它再次声明对赋予的类型必须与其原本的类型相同，否则会产生编译错误。    
> 2. 变量的重声明只可能发生在一个代码块中。如果与当前的变量重名的是外层代码块中的变量，那么久是另外一种含义了，覆盖。
> 3. 变量的重声明只有在使用短变量声明时才会发生，否则无法通过编译。如果要在此处声明全新的变量，那么就应该使用包含关键字var的声明语句，但是这时就不能与同一代码快中的任何变量由重名。    
> 4. 被"声明并赋值"的变量必须是多个，并且其中至少有一个是新的变量。这时我们才可以说对其中的旧变量进行了重声明。    
> 5. 样例`var err error;n,err := Func()`。     

**引用程序实体时，查找过程**    
> * 首先，代码引用变量的时候总会最优先查找当前代码块中的那个变量。不包含任何子代码块。    
> * 其次，如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，从直接包含当前代码块的那个代码开始，一层层向上查找。    
> * 一般情况下，程序会一直查到当前代码包代表的代码块。如果仍然找不到，那么Go语言的编译器就会报错，由于限定符的原因。    
> * 特殊情况，如果我们把代码包导入语句写成import . XXX形式，就会让这个“XXX”包中公开的程序实体，被当前源码代码中的代码，视为当前代码包中的程序实体。      


**类型断言表达式**    
> * 类型断言表达式的语法形式为x.(T)，其中的x代表要被判定类型的值，这个值必须为接口类型，不过具体哪个接口类型其实无所谓，T为类型自变量。    
> * 常用断言表达式为：`value, ok := interface{}(countainer).([]string)`或`value := interface{}(countainer).([]string)`其中前者表示将结果赋值给两个变量，`value`和`ok`，ok为布尔值，`true`时，类型判定正确，被判定的值江北自动转换为`[]string`类型值赋予`value`，否`ok`为`false`，`value`为`nil`;后者当判定为否时将会引起`panic`异常。    
> * 核心图片： ![](/images/posts/2019-2-29-GoKnowlePoint/GoKnowlePoint0.jpg)         

**{}含义**   
> * 一对不包裹任何东西的花括号，除了可以代表空的代码块之外，还可以用于表示不包含任何内容的数据结构（或者说数据类型）。    
> * 举例：`struct{}`，代表不包含任何字段和方法的，空的数据体类型；`interface{}`，代表不包含任何方法定义的，空的接口类型；对于一些集合类的数据类型来说，{}还可以用来表示其值不包含任何元素，比如空的切片值`[]string{}`，以及空的字典值`map[int]string{}`。     

**类型转换规则**     
> * 类型转换表达式的基本写法为T(x)，其中的T为类型，x可以是一个变量，也可以是一个代表值得字面量（比如1.23和struct{}），还可以是一个表达式。x称为源值，类型是源类型，而T代表的类型就是目标类型。   
> * 类型转换常见坑：    
> 1. 首先，对于整数类型值，整数常量之间的类型转换，原则上只要源值在目标类型的可表示范围内就是合法的。    
> 2. 把一个 整数值转换为一个string类型的值是可行的，但值得关注的是，被转换的整数值应该可以代表一个有效的Unicode代码点，否则转换结果将会是“�”（仅由高亮的问好组成的字符串值）。    
> 3. string类型与各切片类型之间的互换，常见切片为`[]byte`和`[]rune`。    

**别名类型和潜在类型**    
> * 核心图片： ![](/images/posts/2019-2-29-GoKnowlePoint/GoKnowlePoint1.jpg)         
> * 别名类型与源类型的区别只在名字上，它们完全是相同的。别名类型主要是为了代码重构而存在的。        
> * 类型再定义，完全定义了一个不同的类型，被重定义类型为潜在类型，其含义是某个类型在本质上市那个类型，或者是那个类型的集合。如何两个潜在类型相同，却属于不同类型，他们之间是可以进行类型转换的，但是不能进行判等或比较，它们的变量之间也不能赋值。再定义类型与潜在类型的值，也可以使用类型转换表达式进行转换。            
     
<br>
### 数组与切片        

        

<br>
持续更新......

<br> 
转载请注明：[HunterYuan的博客](https://clodfisher.github.io/) » [Go常见知识点汇总](https://clodfisher.github.io/2019/02/GoKnowlePoint/)      