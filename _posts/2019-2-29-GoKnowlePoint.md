---
layout: post    
title: Go常见知识点汇总    
date: 2019-02-26    
tags: Go          
---

<br>
### 前言    
对于工作和学习中遇到，容易忘记的知识点进行汇总，方面以后使用的时候，能够及时查到相关点，节约重新学习和搜索的时间。    

<br>
### GO工程布局        
此部分主要总结关于Go语言开发过程中，实现工程化方面知识点。      

**同一个目录下怎样声明源码包**    
> 在同一个目录下的源码文件都需要被声明为属于同一个代码包，这有这有才能通过编译。    

**源码文件代码包声明的基本规则**    
> 第一条：同目录下的源码文件的代码包声明语句要一致。也就是说，他们要同属于一个代码包。这对于所有源码文件都是适用的。    
> 第二条：源码文件声明的代码包的名词可以与其所在的目录的名称不同。在针对代码包进行构建时，生成的结果文件的主名称与其父目录的名称一致。    

**源文件声明代码包与目录名不同如何使用**    
> 源文件所在的目录相对于src目录的相对路径就是他的代码包导入路径，而是将使用其程序实体是给定的限定符（lib.Func，其中lib是限定符，Func是实体）要与它声明所属的代码包名称对应。    

**实体的首字母大小写有何区别**     
> 名称的首字母为大写的程序实体才可以被当前包外的代码引用，否则它就只能被当前包内的其他代码引用。    

<br>
### GO实体    

**什么是程序实体**    
> 在go语言中，程序实体是变量、常量、函数、结构体和接口的统称。使用之前必须先定义程序实体，让后再去使用。程序实体的名字呗统称为标识符，使用来被程序标识和使用的。    

**类型推断的好处**    
> Go语言的类型推断可以明显提升程序的灵活性，使得代码重构变得更加容易，同时又不会给代码的维护带来额外负担（实际上，它恰恰可以避免散弹式的代码修改），更不会损失程序运行效率。    

**变量重声明前提条件**    
> 1. 由于变量的类型在初始化时就已经确定了，所以对它再次声明对赋予的类型必须与其原本的类型相同，否则会产生编译错误。    
> 2. 变量的重声明只可能发生在一个代码块中。如果与当前的变量重名的是外层代码块中的变量，那么久是另外一种含义了，覆盖。
> 3. 变量的重声明只有在使用短变量声明时才会发生，否则无法通过编译。如果要在此处声明全新的变量，那么就应该使用包含关键字var的声明语句，但是这时就不能与同一代码快中的任何变量由重名。    
> 4. 被"声明并赋值"的变量必须是多个，并且其中至少有一个是新的变量。这时我们才可以说对其中的旧变量进行了重声明。    
> 5. 样例`var err error;n,err := Func()`。     

**引用程序实体时，查找过程**    
> * 首先，代码引用变量的时候总会最优先查找当前代码块中的那个变量。不包含任何子代码块。    
> * 其次，如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，从直接包含当前代码块的那个代码开始，一层层向上查找。    
> * 一般情况下，程序会一直查到当前代码包代表的代码块。如果仍然找不到，那么Go语言的编译器就会报错，由于限定符的原因。    
> * 特殊情况，如果我们把代码包导入语句写成import . XXX形式，就会让这个“XXX”包中公开的程序实体，被当前源码代码中的代码，视为当前代码包中的程序实体。      


**类型断言表达式**    
> * 类型断言表达式的语法形式为x.(T)，其中的x代表要被判定类型的值，这个值必须为接口类型，不过具体哪个接口类型其实无所谓，T为类型自变量。    
> * 常用断言表达式为：`value, ok := interface{}(countainer).([]string)`或`value := interface{}(countainer).([]string)`其中前者表示将结果赋值给两个变量，`value`和`ok`，ok为布尔值，`true`时，类型判定正确，被判定的值江北自动转换为`[]string`类型值赋予`value`，否`ok`为`false`，`value`为`nil`;后者当判定为否时将会引起`panic`异常。    
> * 核心图片： ![](/images/posts/2019-2-29-GoKnowlePoint/GoKnowlePoint0.jpg)         

**{}含义**   
> * 一对不包裹任何东西的花括号，除了可以代表空的代码块之外，还可以用于表示不包含任何内容的数据结构（或者说数据类型）。    
> * 举例：`struct{}`，代表不包含任何字段和方法的，空的数据体类型；`interface{}`，代表不包含任何方法定义的，空的接口类型；对于一些集合类的数据类型来说，{}还可以用来表示其值不包含任何元素，比如空的切片值`[]string{}`，以及空的字典值`map[int]string{}`。     

**类型转换规则**     
> * 类型转换表达式的基本写法为T(x)，其中的T为类型，x可以是一个变量，也可以是一个代表值得字面量（比如1.23和struct{}），还可以是一个表达式。x称为源值，类型是源类型，而T代表的类型就是目标类型。   
> * 类型转换常见坑：    
> 1. 首先，对于整数类型值，整数常量之间的类型转换，原则上只要源值在目标类型的可表示范围内就是合法的。    
> 2. 把一个 整数值转换为一个string类型的值是可行的，但值得关注的是，被转换的整数值应该可以代表一个有效的Unicode代码点，否则转换结果将会是“�”（仅由高亮的问好组成的字符串值）。    
> 3. string类型与各切片类型之间的互换，常见切片为`[]byte`和`[]rune`。    

**别名类型和潜在类型**    
> * 核心图片： ![](/images/posts/2019-2-29-GoKnowlePoint/GoKnowlePoint1.jpg)         
> * 别名类型与源类型的区别只在名字上，它们完全是相同的。别名类型主要是为了代码重构而存在的。        
> * 类型再定义，完全定义了一个不同的类型，被重定义类型为潜在类型，其含义是某个类型在本质上市那个类型，或者是那个类型的集合。如何两个潜在类型相同，却属于不同类型，他们之间是可以进行类型转换的，但是不能进行判等或比较，它们的变量之间也不能赋值。再定义类型与潜在类型的值，也可以使用类型转换表达式进行转换。            
     
<br>
### 数组与切片    

**表示方式不同之处**     
> * 切片可以看做是对数组的一层简单的封装，因为在每个切片的底层数据结构中，一定会包含一个数组。数组可以被叫做切片的底层数组，而切片也可以被看做是对数组某个连续片段的引用。    
> * Go语言的切片类型属于引用类型，同属于引用类型的还有字典类型、通道类型、函数类型；而Go语言的数组类型则属于值类型，同属于值类型的有基础数据类型以及结构体类型。    
> * 数组和切片之上都可以应用索引表达式，得到的都会是某个元素。在它们之上也都可以应用切片表达式，也都会得到一个新的切片。     
> * 核心图片： ![](/images/posts/2019-2-29-GoKnowlePoint/GoKnowlePoint2.jpg)         

**切片与数组之间的关系**    
> * 有一窗口，可以通过这个窗口看到一个数组，但是不一定能看到该数组中的所有元素，有时候只能看到连续的一部分数据。其窗口就是切片是对数组的封装，窗口的长度，就是切片本身的长度。    
> * 核心图： ![](/images/posts/2019-2-29-GoKnowlePoint/GoKnowlePoint3.jpg)         
    
**切片的底层数组什么时候被替换**    
> * 确切地说，一个切片的底层数组永远不会被替换，因为只要有切片的创建和数据的追加都是产生一个新的切片类型，来执行新的底层数组或旧的底层数组。每次的操作都是把新的切片作为底层数组的窗口，而没有对原切片进行任何改动。    
> * 举例：在无需扩容时，append函数返回的是指向源底层数组的新切片，而在需要扩容时，append函数返回的是指向新底层数组的新切片。只要长度不会超过切片的原容量，那么使用append函数对其追加元素的时候就不会引起扩容，这只会使紧邻切片窗口右边的（底层数组中的）元素被新的元素替换掉。        
    
<br>
### 字典类型       

**字典的键类型不能使那些类型**    
> * Go语言规范规定，在键类型的值之间必须可以施加操作符`==`和`！=`（处理哈希碰撞）。换句话说，键类型的值必须要支持判等操作。由于函数类型、字典类型和切片类型的值并不支持判等操作，所以字典的键类型不能是这些类型。 另外，如果键的类型是接口类型，那么键值的实际类型也不能是上述三种类型，否则在程序运行过程中会引发`panic`（即运行时恐慌）。    
> * 如果键的类型是数组类型，那么还要确保该类型的元素类型不是函数类型、字典类型或切片类型。     
> * 如果键值类型是结构体类型，那么还要保证其中字段的类型的合法性。    
       
**优先考虑哪些类型作为字典的键类型**        
> * 从性能的角度来看，在整个映射过程中，“把键值转换为哈希值”以及“把查找到的哈希值与哈希桶中的键值做对比”，是两个重要耗时操作，因此可知，求哈希和判等操作的速度越快，对应的类型就越合适作为键类型。    
> * 对于所有的基本类型、指针类型、以及数组类型、结构体类型和接口类型，Go语言都有一套算法。这套算法就包含哈希和判等，以求哈希的操作为例，宽度（单个值需要占用的字节数）越小的类型速度通常越快。  
> * 对于数组类型的值求哈希实际上是依次求得它的每个元素的哈希值并进行合并，所以速度就取决于它的元素类型以及它的长度。    
> * 对于结构体类型的值求哈希实际上就是对它的所有字段值求哈希并进行合并，所以在于它的各个字段的类型以及字段的数量。    
> * 对于接口类型，具体的哈希算法，则有值得实际类型决定。    

**在值为nil的字典上执行那些操作成功与失败**        
> * 对于仅声明而不初始化的字典，它的值是nil，因此叫做nil字典。除了添加键-元素对，在一个键值为nil的字典上做任何操作都不会引起错误。若试图添加键-元素对，运行时系统就会抛出一个`panic`。    
> * 对于空map类型可以进行添加，而对于切片类型的nil和空都可以用append进行添加。             

<br>
持续更新......

<br> 
转载请注明：[HunterYuan的博客](https://clodfisher.github.io/) » [Go常见知识点汇总](https://clodfisher.github.io/2019/02/GoKnowlePoint/)      